\documentclass[dvipdfmx]{jarticle}
\usepackage{graphicx}
\usepackage[top=30truemm,bottom=30truemm,left=25truemm,right=25truemm]{geometry}
\usepackage{listings,jvlisting}
\usepackage{url}

\begin{document}
\begin{titlepage}
    \begin{center}
        {\huge 情報科学演習C　課題2レポ―ト}
        \vspace{180pt}\\
        \begin{tabular}{rl}
            氏名 & 山久保孝亮\\
            所属 & 大阪大学基礎工学部情報科学科ソフトウェア科学コース\\
            メールアドレス & u327468b@ecs.osaka-u.ac.jp\\
            学籍番号 & 09B22084\\
            提出日 & \today\\
            担当教員 & 平井健士,中島悠太
        \end{tabular}
    \end{center}
\end{titlepage}
\section{課題2-1}
\subsection{アルゴリズム}
今回私が作成したechoclientプログラムは以下のような流れで処理を実行する.

\begin{enumerate}
    \item 入力形式の確認
    \item ソケットの生成
    \item ホストが存在するかどうかを確認
    \item ソケットアドレス再利用の指定
    \item ソケット接続先の情報設定
    \item ソケットをサーバーに接続
    \item ユーザからメッセージを取得.7\~9は無限ループとする
    \item メッセージをサーバーに送信
    \item メッセージをサーバーから受信
\end{enumerate}
以下でその詳細について述べる.
\subsubsection{入力形式の確認}
今回のechoclientプログラムは第一引数としてホスト名を指定するという使用法を想定している.そのため,それ以外の使用を制限するために
main関数のコマンドライン引数であるargcの値を確認することで実現した.argcは指定した引数の個数+1の値を表すのでこれが2出ない場合は正しい書式でないとして
エラーメッセージを表示し,プログラムを終了する.
\subsubsection{ソケットの生成}
ソケットを生成するには,socketシステムコールを使用する.socketシステムコールの引数は3つあり,1つ目がドメインの種類,2つ目がソケットの型,3つ目が使用するプロトコルの種類を指定する.
以下のそれぞれの詳細について述べる.\cite{2}\cite{3}
\begin{itemize}
    \item ドメインの種類はAF\_INET,AF\_INET6,AF\_UNIX,AF\_RAWのいずれかである.これにより使用するドメイン内のアドレスの形式である,アドレスファミリーが決定される.これらの
    アドレスファミリーはsys/socket.hインクルードファイルによって定義されている.
    \item ソケットの型にはSOCK\_STREAM,SOCK\_DGRAM,SOCK\_RAWのいずれかである.これによりソケットの型が指定される.
    \\SOCK\_DGRAMはUDPを使用したプロセスの通信を可能にする.データグラムソケットは
    \\SOCK\_RAWは,内部プロトコル(IPなど)のインターフェースを提供し,AF\_INET,AF\_INET6ドメインでサポートされている.
    \\SOCK\_STREAMはTCPを使用したプロセスの通信を可能にする.ストリームソケットは信頼性の高い,順序付けされた重複の無い双方向データフローを提供する.
    \item プロトコルは0,IPPROTO\_UDP,IPPROTO\_TCPのいずれかである.ドメインの種類とソケットの型によってそれぞれデフォルトのプロトコルがあるので,たいていの場合デフォルトを表す0を用いればよい.
\end{itemize}
また,正常に実行された場合は負でないソケット記述子を返し,以上があれば-1を返す.今回はUDPを使用するので
第一引数にはAF\_INET,第二引数にはSOCK\_DGRAM,第三引数には0を指定した.正常にsocketシステムコールが終了したかどうかを確かめるために返り値を格納するint型変数sockの値が0より小さいかどうかを条件分岐で判定する.
正常に実行されていなければエラーメッセージを出力しプログラムを終了する.
\subsubsection{ホストが存在するかどうかを確認}
ホストが存在するかどうかを確認するためにgethostbynameシステムコールを使用した.\cite{4}引数は一つでホスト名を指す文字列である.正常終了するとhostent構造体へのポインタを返し,エラーが発生した場合はNULLを返す.エラーの種類は以下のとおりである.
\begin{itemize}
    \item HOST\_NOT\_FOUND：引数で指定されたホストが見つからなかったとき
    \item TRY\_AGAIN：ローカルサーバが権限サーバから応答を受信しなかったのでもう一度試すよう言われた時
    \item NO\_RECOVERY：リカバリー不能エラー
    \item NO\_ADDRESS：要求されたホスト名は有効だがDNSサーバでIPアドレスが見つからなかったとき
    \item SERVICE\_UNAVAILABLE：指定されたネームサービスが実行されていないか使用可能ではないとき
\end{itemize}
また,hostent構造体は以下のようなメンバを持っている.\cite{5}
\begin{itemize}
    \item h\_name：ホストの名称
    \item h\_aliases：ホストの代替名のリスト
    \item h\_addrtype：返されるアドレスのタイプ
    \item h\_length：アドレスの長さ
    \item h\_addr\_list：ホストのネットワークアドレスのリスト
\end{itemize}
したがって,hostent構造体の構造体変数のポインタとしてserverを定義し,これにgethostbynameシステムコールの返り値を格納した.また,引数にはコマンドライン引数のargv[1]を使用した.
その後gethostbynameシステムコールが正常に終了したかどうかを判定するためにserverにNULLポインタが返されていないかを条件分岐によって確認する.もし返されていればエラーメッセージを出力しプログラムを終了する.
\subsubsection{ソケットアドレス再利用の指定}
setsockopt関数を使ってソケット関連のオプションを設定する.引数は5つあり,いかにその詳細を記述する.\cite{6}\cite{7}
\begin{itemize}
    \item 第一引数：オプションの適用先であるソケット
    \item 第二引数：オプションが設定しているレベル.様々なレベルがあるが,SOL\_SOCKETは第一引数で指定したソケットのオプションのレベルが得られる.
    \item 第三引数：指定するソケットオプションの名前.様々なオプションがあるが,今回使用するSO\_REUSEADDRについて記述する.これは通常一定時間ほかのソケットがそのポートを使えなくなってしまうことを防ぐことができるようになる.\cite{8}
    \item 第四引数：オプションデータへのポインタ.SO\_RESUSEADDRを有効にするには整数型で1の値が渡される.
    \item 第五引数：オプションデータの長さ.
\end{itemize}
また,返り値は正常に実行された場合は0を返し,されなかった場合は-1を返す.したがって,今回作成したプログラムではint型変数reuseを1に設定し,setsockopt関数の引数に使用して正常に実行されたかを確認するために返り値が0未満かどうかで条件分岐をさせた.
正しく実行されていなかった場合はエラーメッセージを出力しプログラムを終了した.
\subsubsection{ソケット接続先の情報設定}
ここでは,hostnet構造体とsockaddr\_in構造体のメンバに情報を格納している.sockaddr\_in構造体のメンバは以下のようになっている.\cite{9}
\begin{itemize}
    \item sin\_family：アドレスファミリを指定
    \item sin\_part：ポート番号を指定
    \item sin\_addr：IPアドレスをin\_addr構造体で指定
    \item sin\_zero[8]：OSの内部仕様専用
\end{itemize}
sockaddr\_in構造体の構造体変数名はsvrとした.以下のプログラムのように情報を設定した.
1行目ではsvrのすべてのメンバをbzero関数を使ってゼロに初期化している.2行目はsvrのメンバsin\_familyにAF\_INETを設定している.1.1.2より,ソケットのアドレスファミリーを指定し,このソケットがIPv4を使用すると設定する.
3行目ではサーバーのIPアドレスを1.1.5で取得し,serverのメンバに格納されているサーバーのIPアドレスをsvrのメンバにbcopy関数を使ってコピーする.4行目ではsvrのメンバにポート番号を指定している.
\subsubsection{ソケットをサーバーに接続}
ここではconnectシステムコールを使ってソケットをサーバに接続している.connectシステムコールの引数は以下のようになる.\cite{10}
\begin{itemize}
    \item s：接続されていないソケットを識別する記述子
    \item name：接続を確立する必要があるsockaddr構造体へのポインター
    \item namelen：nameパラメータがさすsockaddr構造体の長さ
\end{itemize}
また,返り値は正常に終了した場合は0を,異常が発生すると-1を返す.
今回のプログラムでは第一引数にsock,第二引数にsvrへのポインタ,第三引数にsvr構造体の長さを格納している.そして
connectシステムコールの返り値が0より小さければ異常が発生したとしてソケットを閉じてプログラムを終了する.
\subsubsection{繰り返し処理}
今回のプログラムの仕様では標準入力から読み込んだ文字列をサーバプログラムへ送信し受信した文字列をEOFを受け取るまで繰り返すというものであった.
したがって,以下の1.1.8と11.9で記述するメッセージの送信と受信はEOFが入力されるまで繰り返し実行される必要があるから,while文を使ってそれらの処理を無限ループにした.
つまり,各ループごとにユーザにfgets関数を使って標準入力から文字列を配列rbufに格納し,それをサーバに送信,受信するというアルゴリズムを採用した.
\subsubsection{メッセージをサーバーに送信}
ここではwriteシステムコールを使ってソケットにデータを送信している.writeシステムコールの引数は以下のようになる.\cite{12}
\begin{itemize}
    \item fs：ソケット記述子
    \item buf：書き込まれるデータを保留するバッファを指すポインタ
    \item n：bufパラメータが指すバッファの長さ
\end{itemize}
返り値は,正常に実行されたときは0以上の値を返し正常に実行されなかった場合は-1を返す.
fsにはsock,bufにはrbuf,nにはstrlen関数を使って取得したbufの長さを設定した.そして変数nにwriteシステムコールの返り値を格納する.
nが0より小さければ異常に終了したと判定しソケットを閉じてプログラムを終了する.
\subsubsection{メッセージをサーバーから受信}
ここではreadシステムコールを使ってソケットからデータを読み取っている.readシステムコールの
引数は以下のようになる.\cite{13}
\begin{itemize}
    \item fs：ファイルまたはソケットの記述子
    \item buf：データを受け取るバッファへのポインタ
    \item n：bufパラメータがさすバッファの長さ
\end{itemize}
返り値は,正常に実行されたときは読み込んだバイト数を,異常終了した場合は-1を返す.\cite{14}
今回のプログラムではfsにsock,bufにrbuf,nにはstrlen関数を使って取得したbufの長さを設定した.
そして変数nにreadシステムコールの返り値を格納する.
nが0より小さければ異常に終了したと判定しソケットを閉じてプログラムを終了する.
\subsection{実行結果}

\section{課題2-2}
\subsection{アルゴリズム}
今回私が作成したsimple-talk-serverプログラムは以下のような流れで処理を実行する.
\begin{enumerate}
    \item ソケットの生成
    \item ソケットアドレスの再利用の設定
    \item クライアント受け付け用ソケットの情報設定
    \item ソケットアドレスの割り当て
    \item 待ち受けクライアント数の設定
    \item クライアント受け付け
    \item クライアントホスト情報の取得
    \item selectシステムコールの設定
    \item selectシステムコールによって以下の処理のどちらを行うか判定する.
    \begin{itemize}
        \item 読み込みクライアントに送信
        \item ソケットから読み込み
    \end{itemize}
\end{enumerate}
また,simple-talk-clientプログラムは以下のような流れで処理を実行する.
\subsection{実行結果}

\section{発展課題}

\section{感想}
今回の課題を通してUDP及びTCPへの理解が深まり,またプログラムを使ってどのようにサーバーとクライアントが接続されるのかを理解することができた.
個人的にネットワークには興味があるので,今後の課題も興味を持ちながら取り組んでいきたいと思う.
\section{謝辞}
今回の課題を通して質問対応,レポート採点等をしてくださった教授,TAの皆様方ありがとうございまし
た.今後の課題もよろしくお願いいたします.
\begin{thebibliography}{99}
    \bibitem{1}情報科学演習C指導書
    \bibitem{2} \url{https://www.ibm.com/docs/ja/zos/2.5.0?topic=functions-socket-create-socket} 5/21アクセス
    \bibitem{3} \url{https://ryuichi1208.hateblo.jp/entry/2020/03/20/144644} 5/21アクセス
    \bibitem{4} \url{https://www.ibm.com/docs/ja/aix/7.3?topic=g-gethostbyname-subroutine} 5/21アクセス
    \bibitem{5} \url{https://www.qnx.com/developers/docs/8.0/com.qnx.doc.neutrino.lib_ref/topic/h/hostent.html} 5/21アクセス
    \bibitem{6} \url{https://www.ibm.com/docs/ja/zos/2.4.0?topic=functions-setsockopt-set-options-associated-socket} 5/21アクセス
    \bibitem{7} \url{https://docs.oracle.com/cd/E19455-01/806-2730/sockets-49/index.html} 5/21アクセス
    \bibitem{8} \url{https://qiita.com/bamchoh/items/1dd44ba1fbef43b5284b} 5/21アクセス
    \bibitem{9} \url{https://www.opto-support.com/oph5000sdk/ja/BuiltIn_WLAN_Library_Structures_sockaddr_in.html} 5/27アクセス
    \bibitem{10} \url{https://learn.microsoft.com/ja-jp/windows/win32/api/winsock2/nf-winsock2-connect} 5/27アクセス
    \bibitem{11} \url{https://ja.manpages.org/connect/2} 5/27アクセス
    \bibitem{12} \url{https://www.ibm.com/docs/ja/zos/2.5.0?topic=functions-write-write-data-file-socket} 5/27アクセス
    \bibitem{13} \url{https://www.ibm.com/docs/ja/zos/2.5.0?topic=functions-read-read-from-file-socket} 5/27アクセス
    \bibitem{14} \url{https://cgengo.sakura.ne.jp/read.html} 5/27アクセス
\end{thebibliography}
\end{document}