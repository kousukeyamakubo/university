\documentclass[dvipdfmx]{jarticle}
\usepackage{graphicx}
\usepackage[top=30truemm,bottom=30truemm,left=25truemm,right=25truemm]{geometry}
\usepackage{listings,jvlisting}
\usepackage{url}

\lstset{
  basicstyle={\ttfamily},
  identifierstyle={\small},
  commentstyle={\smallitshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=3zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}

\makeatletter
\newcommand{\subsubsubsection}{\@startsection{paragraph}{4}{\z@}%
  {1.0\Cvs \@plus.5\Cdp \@minus.2\Cdp}%
  {.1\Cvs \@plus.3\Cdp}%
  {\reset@font\sffamily\normalsize}
}
\makeatother
\setcounter{secnumdepth}{4}

\begin{document}
\begin{titlepage}
    \begin{center}
        {\huge 情報科学演習D　課題3レポ―ト}
        \vspace{180pt}\\
        \begin{tabular}{rl}
            氏名 & 山久保孝亮\\
            所属 & 大阪大学基礎工学部情報科学科ソフトウェア科学コース\\
            メールアドレス & u327468b@ecs.osaka-u.ac.jp\\
            学籍番号 & 09B22084\\
            提出日 & \today\\
            担当教員 & 桝井晃基　松本真佑
        \end{tabular}
    \end{center}
\end{titlepage}
\section{システムの仕様}
課題3の外部仕様は以下のようになる．
\begin{itemize}
  \item 第一引数で指定されたtsファイルを読み込んでい未解析を行い，意味的に正しい場合は文字列"OK"を，正しくない場合は文字列"Semantic Error"に続いて対応する行番号を返す．
  \item 複数の意味的誤りが含まれる場合では，最初に見つけた誤りのみを出力する．
  \item 意味解析よりも先に構文解析を適用し，構文エラーを見つけると”Syntaxerror: line”という文字列に続いて対応する行番号を返す．
  \item 入力ファイルが見つからない場合は文字列”Filenot Found”を返す．
\end{itemize}
\section{課題達成の方針と設計}
課題3のテストケースをパスするために実装した機能は以下の通りである．
\begin{enumerate}
  \item 変数が重複して定義されない．
  \item 未定義の変数及び関数を参照しない．
  \item 型における制約を守る．
  \item 代入文の左辺に配列型の変数名を使用しない．
\end{enumerate}
課題3では課題2のparser.javaのプログラムの一部を変更して実装した．上記の機能を満足するために変
更及び追加した方針は以下の通りである．
\begin{itemize}
  \item 変数名，関数名等を記憶するための表を作成する．今回作成した表は言語処理工学Aの授業スライドを参考にして作成しており，記号表，関数表，変数表の三つである．
  記号表は宣言の重複を，変数表は未定義の変数の参照を，関数表は未定義の手続きの呼び出しを防ぐために作成した．それぞれの表の構成要素は以下の表の通りである．
  \begin{table}[h]
    \centering
    \begin{tabular}{|c||c|c|c|}
      \hline
      記号表 & 記号名 & 記号の種類 & 記号の型\\\hline
      変数表 & 変数名 & 変数の型 & 記号の型\\\hline
      関数表 & 関数名 & 引数の型 & null\\\hline
    \end{tabular}
    \caption{それぞれの表の構成要素}
  \end{table}
  \\null は要素が存在しないことを，つまり関数表には二つの要素しか存在しないことを表す．〇〇名及び〇〇の型はそれぞれの表に格納される識別子及び標準型のいずれかを格納する．
  記号の種類にはプログラム，変数，手続きの内いずれであるかを格納する．変数のサイズには配列の際は要素数を，配列でなければ1を格納する．
  \\
  表を活用するためにはまず格納する必要があるが，そのタイミングについては3の実装プログラムで詳細を述べる．宣言の重複について，指導書よりプログラムの宣言と手続きの宣言で処理を分ける必要がある．
  したがって，変数表はグローバル変数用のものとローカル変数用のものをそれぞれ用意した．これにより，グローバル変数を宣言する処理の際はグローバル変数用の変数表と関数表を，ローカル変数を宣言する処理の際はローカル変数用の変数表と関数表を参照することによって要件を満足することができた．
  また，未定義の変数の参照について，ローカル変数用の表，グローバル変数用の表の順番で探索するようにした．これにより，グローバル変数でもローカル変数でも定義されている変数名に対して，ローカル変数として正しく参照できるようにした．
  \item 式，単純式，項，因子を判定するメソッドが型を返すようにする．課題2では構文定義を判定するメソッドはすべてvoid型であったが，前述のメソッドが”integer”,”char”,”boolean”のいずれかをString型で返すようにした．
  これにより，各被演算子の型を把握することができるので，型の整合性がとれているのか，特定の演算子に適した型が使用されているのかを判定する．
\end{itemize}
\section{実装プログラム}
今回実装したプログラムは以下の3つである．
\subsection{意味エラーの検出}
\subsection{表の作成}
2で記述したように，変数の情報を記録しておくために表を作成した．それぞれの表に対応するsymbol,variable,functionというクラスを作成し，それぞれグローバル変数のリストとしてどのメソッドからでも参照できるようにした．
それぞれのクラス内の変数は表1に対応しており，それぞれのクラス内で以下のようなメソッドを作成した．
\begin{lstlisting}
  public Type get_A_B(){
    return B;
  }
\end{lstlisting}
ここではAがどの表であるか，Bが表のどの変数であるかに対応している．これにより，例えばvariableというリストのi番目の要素に対して上記のメソッドを実行すればi番目のBの値を参照できるようになる．
\subsection{表への格納}
表への格納はStoreToTable()を定義して実現した．StoreToTable()のプログラムは以下のようになる．
\begin{lstlisting}
  private void StoreToTable(ArrayList<Object> list) {
		String type = (String) list.get(0);
		int size = (int) list.get(1);
		if(global_flag == true) {
			for(int i = 0;i<list_of_variablename.size();i++) {
				global_variable_table.add(new variable(list_of_variablename.get(i),type,size));
				symbol_table.add(new symbol(list_of_variablename.get(i),"variable",type));
			}
		}else {
			for(int i = 0;i<list_of_variablename.size();i++) {
				local_variable_table.add(new variable(list_of_variablename.get(i),type,size));
				symbol_table.add(new symbol(list_of_variablename.get(i),"variable",type));
			}
		}
		list_of_variablename.clear();
	}
\end{lstlisting}

\subsection{型の制約}
\section{考察}
\section{感想}
課題3を通して学んだ感想としては，課題2においてウォータフォール型の開発をしたことの反省から
テストファーストな開発を試してみて，かなり効率的に実装を進めることができたと感じている．
\begin{thebibliography}{1}
    \bibitem{1} 
\end{thebibliography}
\end{document}